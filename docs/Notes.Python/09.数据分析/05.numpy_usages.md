---
title: numpy_usage
date: 2022-06-06 10:22:54
permalink: /pages/b683c6/
category:
  - Python
  - 数据分析
tag:
  - 
---
### 导入包


```python
import numpy as np
import matplotlib.pyplot as plt
```

### 查看版本


```python
np.__version__
```

:heavy_check_mark: Output


    '1.21.5'




```python
np.show_config()
```

:heavy_check_mark: Output

    blas_mkl_info:
        libraries = ['mkl_rt']
        library_dirs = ['D:/ProgramFiles/Anaconda\\Library\\lib']
        define_macros = [('SCIPY_MKL_H', None), ('HAVE_CBLAS', None)]
        include_dirs = ['D:/ProgramFiles/Anaconda\\Library\\include']
    blas_opt_info:
        libraries = ['mkl_rt']
        library_dirs = ['D:/ProgramFiles/Anaconda\\Library\\lib']
        define_macros = [('SCIPY_MKL_H', None), ('HAVE_CBLAS', None)]
        include_dirs = ['D:/ProgramFiles/Anaconda\\Library\\include']
    lapack_mkl_info:
        libraries = ['mkl_rt']
        library_dirs = ['D:/ProgramFiles/Anaconda\\Library\\lib']
        define_macros = [('SCIPY_MKL_H', None), ('HAVE_CBLAS', None)]
        include_dirs = ['D:/ProgramFiles/Anaconda\\Library\\include']
    lapack_opt_info:
        libraries = ['mkl_rt']
        library_dirs = ['D:/ProgramFiles/Anaconda\\Library\\lib']
        define_macros = [('SCIPY_MKL_H', None), ('HAVE_CBLAS', None)]
        include_dirs = ['D:/ProgramFiles/Anaconda\\Library\\include']
    Supported SIMD extensions in this NumPy install:
        baseline = SSE,SSE2,SSE3
        found = SSSE3,SSE41,POPCNT,SSE42,AVX,F16C,FMA3,AVX2
        not found = AVX512F,AVX512CD,AVX512_SKX,AVX512_CLX,AVX512_CNL


### 创建空向量


```python
np.zeros(10)
```

:heavy_check_mark: Output


    array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])



### 获取numpy函数文档


```python
np.info(np.add)
```

:heavy_check_mark: Output

    add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])
    
    Add arguments element-wise.
    
    Parameters
    ----------
    x1, x2 : array_like
        The arrays to be added.
        If ``x1.shape != x2.shape``, they must be broadcastable to a common
        shape (which becomes the shape of the output).
    out : ndarray, None, or tuple of ndarray and None, optional
        A location into which the result is stored. If provided, it must have
        a shape that the inputs broadcast to. If not provided or None,
        a freshly-allocated array is returned. A tuple (possible only as a
        keyword argument) must have length equal to the number of outputs.
    where : array_like, optional
        This condition is broadcast over the input. At locations where the
        condition is True, the `out` array will be set to the ufunc result.
        Elsewhere, the `out` array will retain its original value.
        Note that if an uninitialized `out` array is created via the default
        ``out=None``, locations within it where the condition is False will
        remain uninitialized.
    **kwargs
        For other keyword-only arguments, see the
        :ref:`ufunc docs <ufuncs.kwargs>`.
    
    Returns
    -------
    add : ndarray or scalar
        The sum of `x1` and `x2`, element-wise.
        This is a scalar if both `x1` and `x2` are scalars.
    
    Notes
    -----
    Equivalent to `x1` + `x2` in terms of array broadcasting.
    
    Examples
    --------
    >>> np.add(1.0, 4.0)
    5.0
    >>> x1 = np.arange(9.0).reshape((3, 3))
    >>> x2 = np.arange(3.0)
    >>> np.add(x1, x2)
    array([[  0.,   2.,   4.],
           [  3.,   5.,   7.],
           [  6.,   8.,  10.]])
    
    The ``+`` operator can be used as a shorthand for ``np.add`` on ndarrays.
    
    >>> x1 = np.arange(9.0).reshape((3, 3))
    >>> x2 = np.arange(3.0)
    >>> x1 + x2
    array([[ 0.,  2.,  4.],
           [ 3.,  5.,  7.],
           [ 6.,  8., 10.]])


### 创建一个值从10到49的向量


```python
np.arange(10,50)
```

:heavy_check_mark: Output


    array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,
           27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
           44, 45, 46, 47, 48, 49])



### 反转向量
通过冒号分隔切片参数 start:stop:step 来进行切片操作


```python
np.arange(50)[::-1]
```

:heavy_check_mark: Output


    array([49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33,
           32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16,
           15, 14, 13, 12, 11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1,  0])



### 创建一个0-8 的3×3矩阵


```python
np.arange(9).reshape(3,3)
```

:heavy_check_mark: Output


    array([[0, 1, 2],
           [3, 4, 5],
           [6, 7, 8]])



### 找到非0元素下标


```python
np.nonzero([0,0,1,2,0,5,12,0,123])
```

:heavy_check_mark: Output


    (array([2, 3, 5, 6, 8], dtype=int64),)



### 创建3×3单位矩阵


```python
np.eye(3)
```

:heavy_check_mark: Output


    array([[1., 0., 0.],
           [0., 1., 0.],
           [0., 0., 1.]])



### 创建一个2×4×5数组


```python
np.random.random((2,4,5))
```

:heavy_check_mark: Output


    array([[[0.45386552, 0.13387667, 0.04665661, 0.35189077, 0.88951735],
            [0.12221884, 0.15473646, 0.99348358, 0.24136832, 0.11330058],
            [0.12524342, 0.69062195, 0.75876268, 0.80288943, 0.62294584],
            [0.97950832, 0.21553173, 0.78279694, 0.60119906, 0.220021  ]],
    
           [[0.01919939, 0.30617933, 0.62005418, 0.04749623, 0.99852464],
            [0.15405654, 0.87161046, 0.80881559, 0.29023097, 0.18789697],
            [0.54485917, 0.08019977, 0.89280335, 0.93069048, 0.43466569],
            [0.06779827, 0.04610077, 0.20112259, 0.77409674, 0.73360443]]])



### 获取最大值\最小值\平均值


```python
z = np.random.random((10,10))
(z.min(),z.max(),z.mean())
```

:heavy_check_mark: Output


    (0.007672562518892034, 0.9962144269292328, 0.5640046187854826)



### 12 创建一个边界为1,内部为0的2维数组


```python
z = np.ones((10,10))
z[1:-1,1:-1] = 0
z
```

:heavy_check_mark: Output


    array([[1., 1., 1., 1., 1., 1., 1., 1., 1., 1.],
           [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
           [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
           [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
           [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
           [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
           [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
           [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
           [1., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
           [1., 1., 1., 1., 1., 1., 1., 1., 1., 1.]])



### nan计算


```python
0*np.nan
```

:heavy_check_mark: Output


    nan




```python
np.nan==np.nan
```

:heavy_check_mark: Output


    False




```python
np.inf>np.nan
```

:heavy_check_mark: Output


    False




```python
np.nan-np.nan
```

:heavy_check_mark: Output


    nan




```python
0.3==3*0.1
```

:heavy_check_mark: Output


    False



### 创建一个5×5矩阵,对角线值为1,2,3,4
以一维数组的形式返回方阵的对角线（或非对角线）元素，或将一维数组转换成方阵（非对角线元素为0）.两种功能角色转变取决于输入的`v`

`v : array_like`:
* 如果v是2D数组，返回k位置的对角线。
* 如果v是1D数组，返回一个v作为k位置对角线的2维数组。

`k : int, optional`:
对角线的位置，大于零位于对角线上面，小于零则在下面。


```python
np.diag(1+np.arange(4),k=-1)
```

:heavy_check_mark: Output


    array([[0, 0, 0, 0, 0],
           [1, 0, 0, 0, 0],
           [0, 2, 0, 0, 0],
           [0, 0, 3, 0, 0],
           [0, 0, 0, 4, 0]])



### 创建一个8×8 的矩阵,使用0,1间隔填充


```python
z = np.zeros((8,8),dtype = int)
z[1::2,::2] = 1
z[::2,1::2] = 1
z
```

:heavy_check_mark: Output


    array([[0, 0, 0, 0, 0, 0, 0, 0],
           [1, 0, 1, 0, 1, 0, 1, 0],
           [0, 0, 0, 0, 0, 0, 0, 0],
           [1, 0, 1, 0, 1, 0, 1, 0],
           [0, 0, 0, 0, 0, 0, 0, 0],
           [1, 0, 1, 0, 1, 0, 1, 0],
           [0, 0, 0, 0, 0, 0, 0, 0],
           [1, 0, 1, 0, 1, 0, 1, 0]])



### 取(6,7,8)形状数组的第100个元素下标


```python
np.unravel_index(100,(6,7,8))
```

:heavy_check_mark: Output


    (1, 5, 4)



### 使用tile函数创建一个8x8的0，1间隔填充矩阵
 `numpy.title(data,(x,y))` 为扩展函数，`data`为要扩展的数据，类型为np类型数组，`x`,扩展行数，`y`扩展列数，


```python
np.tile( np.array([[0,1],[1,0]]), (4,4))
```

:heavy_check_mark: Output


    array([[0, 1, 0, 1, 0, 1, 0, 1],
           [1, 0, 1, 0, 1, 0, 1, 0],
           [0, 1, 0, 1, 0, 1, 0, 1],
           [1, 0, 1, 0, 1, 0, 1, 0],
           [0, 1, 0, 1, 0, 1, 0, 1],
           [1, 0, 1, 0, 1, 0, 1, 0],
           [0, 1, 0, 1, 0, 1, 0, 1],
           [1, 0, 1, 0, 1, 0, 1, 0]])



### 标准化随机矩阵


```python
z = np.random.random((5,5))
z_min,z_max = z.min(),z.max()
z_stander = (z-z_min)/(z_max-z_min)
z_stander
```

:heavy_check_mark: Output


    array([[0.22224275, 0.73255274, 0.69018083, 0.22123295, 0.20480331],
           [0.69290723, 0.63332885, 0.75645768, 0.35435768, 0.21247509],
           [0.59406065, 0.88113708, 0.82996655, 0.30010581, 0.88672685],
           [0.39553412, 0.02396734, 0.72621264, 0.97607788, 0.30112772],
           [1.        , 0.47109107, 0.        , 0.19756056, 0.950349  ]])



### 创建一个自定义的`dtype`,将颜色描述为4个`unsigned`字节(RGBA)
* `type()`是python内置的函数。`type()` 返回数据结构类型`list`、`dict`、`numpy.ndarray` 等
* `dtype` 返回数据元素的数据类型`int`、`float`等
* `astype()` 改变`np.array`中所有数据元素的数据类型。

> * 由于 `list`、`dict` 等可以包含不同的数据类型，因此没有`dtype`属性
> * `np.array` 中要求所有元素属于同一数据类型，因此有`dtype`属性
> * 能用`dtype()` 才能用`astype()`


```python

color = np.dtype([("r", np.ubyte),
("g", np.ubyte),
("b", np.ubyte),
("a", np.ubyte)])
color
```

:heavy_check_mark: Output


    dtype([('r', 'u1'), ('g', 'u1'), ('b', 'u1'), ('a', 'u1')])




```python
colist = np.array([(255,2,3,0.5),(15,6,7,15)],dtype=color)
colist
```

:heavy_check_mark: Output


    array([(255, 2, 3,  0), ( 15, 6, 7, 15)],
          dtype=[('r', 'u1'), ('g', 'u1'), ('b', 'u1'), ('a', 'u1')])




```python
colist['r']
```

:heavy_check_mark: Output


    array([255,  15], dtype=uint8)



### 将一个5×3矩阵乘以一个3×2矩阵(实矩阵乘积)


```python
x,y = np.random.random((5,3)),np.random.random((3,2))
x_times_y = np.dot(x,y)
x,y,x_times_y
```

:heavy_check_mark: Output


    (array([[0.89205272, 0.60520359, 0.41292212],
            [0.78148754, 0.21106993, 0.05480317],
            [0.82803222, 0.34984876, 0.01204298],
            [0.80889325, 0.84080905, 0.68135092],
            [0.24217435, 0.60347122, 0.64177374]]),
     array([[0.04503221, 0.40305574],
            [0.58283611, 0.58695645],
            [0.62636256, 0.98888873]]),
     array([[0.65154457, 1.12310915],
            [0.19253794, 0.49306613],
            [0.24873588, 0.5509983 ],
            [0.95325284, 1.49332761],
            [0.76461351, 1.0864639 ]]))



### 给定一个数组,对3到8之间的元素求反


```python
z = np.arange(12)
z[(3<z)&(z<=8)] *= -1
# z[(3<z)&(z<=8)] = 2*z[(3<z)&(z<=8)] # 每个元素乘2
z
```

:heavy_check_mark: Output


    array([ 0,  1,  2,  3, -4, -5, -6, -7, -8,  9, 10, 11])



### 注意`numpy.sum()`和python自带的`sum()`区别


```python
sum(range(5),-1)
```

:heavy_check_mark: Output


    9




```python
np.sum(range(5),-1)
```

:heavy_check_mark: Output


    10



### 四舍五入
原值加0.5后舍弃小数位


```python
z = np.random.uniform(-10,+10,10)
z,np.copysign(0.5,z),np.trunc(z+np.copysign(0.5,z))
```

:heavy_check_mark: Output


    (array([ 9.23569476,  6.35241247, -1.33141561,  0.57033032,  9.1610334 ,
             8.29838566,  9.24065524,  7.20426499, -6.35617525,  2.96421073]),
     array([ 0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5]),
     array([ 9.,  6., -1.,  1.,  9.,  8.,  9.,  7., -6.,  3.]))



### 提取随机数组的整数部分


```python
z = np.random.uniform(0,10,10)
z, z-z%1, np.floor(z), np.ceil(z)-1, z.astype(int), np.trunc(z)
```

:heavy_check_mark: Output


    (array([5.19275227, 4.23215837, 9.88650662, 7.90704207, 6.8734058 ,
            6.89792157, 6.64949873, 2.09577292, 7.80764776, 8.84498414]),
     array([5., 4., 9., 7., 6., 6., 6., 2., 7., 8.]),
     array([5., 4., 9., 7., 6., 6., 6., 2., 7., 8.]),
     array([5., 4., 9., 7., 6., 6., 6., 2., 7., 8.]),
     array([5, 4, 9, 7, 6, 6, 6, 2, 7, 8]),
     array([5., 4., 9., 7., 6., 6., 6., 2., 7., 8.]))



### 创建一个值范围0-4的5×5矩阵


```python
z= np.zeros((5,5))+np.arange(5)
z
```

:heavy_check_mark: Output


    array([[0., 1., 2., 3., 4.],
           [0., 1., 2., 3., 4.],
           [0., 1., 2., 3., 4.],
           [0., 1., 2., 3., 4.],
           [0., 1., 2., 3., 4.]])



### 创建生成器函数,生成10个整数并使用它来构建一个数组


```python
def generate():
    for x in range(10):
        yield x*2
z = generate()
```


```python
np.fromiter(generate(),dtype=float,count = -1)
```

:heavy_check_mark: Output


    array([ 0.,  2.,  4.,  6.,  8., 10., 12., 14., 16., 18.])



### 创建一个大小为10的向量,其值为0到1


```python
np.linspace(0,1,12,endpoint=True)[1:-1]
```

:heavy_check_mark: Output


    array([0.09090909, 0.18181818, 0.27272727, 0.36363636, 0.45454545,
           0.54545455, 0.63636364, 0.72727273, 0.81818182, 0.90909091])



### 创建一个大小为10的随机向量并对其进行排序


```python
z = np.random.random(10)
z.sort()
z
```

:heavy_check_mark: Output


    array([0.04646627, 0.25305676, 0.34466799, 0.38696836, 0.40498888,
           0.4487169 , 0.50654849, 0.54599159, 0.89077484, 0.93294665])



### 如何比`np.sum()`更快地求和一个小数组


```python
z = np.arange(10)
np.add.reduce(z)
```

:heavy_check_mark: Output


    45



### 考虑检查两个随机数组A和B是否相等


```python
A = np.random.randint(0,2,5)
B = np.random.randint(0,2,5)
A,B,np.allclose(A,B)
```

:heavy_check_mark: Output


    (array([1, 1, 0, 1, 1]), array([0, 1, 0, 0, 1]), False)



### 使数组只读


```python
z = np.zeros(10)
z.flags.writeable = False
try:
    z[0] = 1
except Exception as e:
    print(e)
finally:
    print(z)
```

:heavy_check_mark: Output

    assignment destination is read-only
    [0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]


### 一个表示笛卡尔积地随机10×2矩阵(按x从小到大排序),将他们转换为极坐标


```python
z = np.random.random((10,2))
z=z[np.argsort(z[:,0])]
x, y = z[:,0], z[:,1]
r, t = np.sqrt(x**2+y**2) , np.arctan2(y,x)
```

:heavy_check_mark: Output


```python
plt.plot(x,y)
plt.show()
plt.polar(r,t)
plt.show()
z,x,y,r,t

```


![png](http://minio.vancode.top/typora/20220606170847.png)
    




![png](http://minio.vancode.top/typora/20220606170906.png)
    





    (array([[0.09750566, 0.40694266],
            [0.22222408, 0.0216276 ],
            [0.23670313, 0.28252879],
            [0.4778665 , 0.37918515],
            [0.52243626, 0.9865198 ],
            [0.57682401, 0.57129313],
            [0.59267086, 0.80758161],
            [0.64121593, 0.68005324],
            [0.94424887, 0.99559935],
            [0.98904989, 0.54107718]]),
     array([0.09750566, 0.22222408, 0.23670313, 0.4778665 , 0.52243626,
            0.57682401, 0.59267086, 0.64121593, 0.94424887, 0.98904989]),
     array([0.40694266, 0.0216276 , 0.28252879, 0.37918515, 0.9865198 ,
            0.57129313, 0.80758161, 0.68005324, 0.99559935, 0.54107718]),
     array([0.41846108, 0.22327403, 0.36857955, 0.61003096, 1.11631579,
            0.81185083, 1.00172192, 0.93468191, 1.37216034, 1.12737935]),
     array([1.33562449, 0.09701784, 0.8734267 , 0.67076247, 1.08376957,
            0.78058086, 0.93768979, 0.81478364, 0.81186338, 0.50058908]))



### 创建大小为10 的随机向量并将最大值替换为0


```python
z = np.random.random(10)
print(z)
z[z.argmax()] = 0
z
```

:heavy_check_mark: Output

    [0.12845752 0.53043072 0.42460493 0.23774745 0.94741987 0.34580642
     0.1419344  0.98454567 0.09271457 0.42953805]



:heavy_check_mark: Output

    array([0.12845752, 0.53043072, 0.42460493, 0.23774745, 0.94741987,
           0.34580642, 0.1419344 , 0.        , 0.09271457, 0.42953805])



### 创建一个结构化数组,其中x和坐标覆盖[0,1]×[0,1]区域
基于网格点的规律性，可以使用`numpy.meshgrid()`直接生成想要的网格点就好了
还以二维平面举例：给定X轴和Y轴所有的点，将X和Y放到两个数组，进行笛卡尔乘积，从而得到所有的点。


```python
z = np.zeros((5,5), [('x',float),('y',float)])
z['x'],z['y'] = np.meshgrid(np.linspace(0,1,5),np.linspace(0,1,5))
plt.plot(z['x'],z['y'],marker='.',linestyle='')
z['x'],z['y']
```

:heavy_check_mark: Output


    (array([[0.  , 0.25, 0.5 , 0.75, 1.  ],
            [0.  , 0.25, 0.5 , 0.75, 1.  ],
            [0.  , 0.25, 0.5 , 0.75, 1.  ],
            [0.  , 0.25, 0.5 , 0.75, 1.  ],
            [0.  , 0.25, 0.5 , 0.75, 1.  ]]),
     array([[0.  , 0.  , 0.  , 0.  , 0.  ],
            [0.25, 0.25, 0.25, 0.25, 0.25],
            [0.5 , 0.5 , 0.5 , 0.5 , 0.5 ],
            [0.75, 0.75, 0.75, 0.75, 0.75],
            [1.  , 1.  , 1.  , 1.  , 1.  ]]))




![png](http://minio.vancode.top/typora/20220606171253.png)
    


### 给定两个数组 X 和 Y，构造柯西矩阵
柯西矩阵 
 C (C_{ij} = 1/(x_i-y_j))


```python
x = np.arange(8)
y = x+0.5
c = 1.0 / np.subtract.outer(x,y)
# np.linalg.det(c)
c
```

:heavy_check_mark: Output


    array([[-2.        , -0.66666667, -0.4       , -0.28571429, -0.22222222,
            -0.18181818, -0.15384615, -0.13333333],
           [ 2.        , -2.        , -0.66666667, -0.4       , -0.28571429,
            -0.22222222, -0.18181818, -0.15384615],
           [ 0.66666667,  2.        , -2.        , -0.66666667, -0.4       ,
            -0.28571429, -0.22222222, -0.18181818],
           [ 0.4       ,  0.66666667,  2.        , -2.        , -0.66666667,
            -0.4       , -0.28571429, -0.22222222],
           [ 0.28571429,  0.4       ,  0.66666667,  2.        , -2.        ,
            -0.66666667, -0.4       , -0.28571429],
           [ 0.22222222,  0.28571429,  0.4       ,  0.66666667,  2.        ,
            -2.        , -0.66666667, -0.4       ],
           [ 0.18181818,  0.22222222,  0.28571429,  0.4       ,  0.66666667,
             2.        , -2.        , -0.66666667],
           [ 0.15384615,  0.18181818,  0.22222222,  0.28571429,  0.4       ,
             0.66666667,  2.        , -2.        ]])



### 打印每个numpy标量类型最小和最大可表示的值


```python

for dtype in [np.int8, np.int32, np.int64]:
    print(np.iinfo(dtype).min)
    print(np.iinfo(dtype).max)
for dtype in [np.float32, np.float64]:
    print(np.finfo(dtype).min)
    print(np.finfo(dtype).max)
    print(np.finfo(dtype).eps)
```

:heavy_check_mark: Output

    -128
    127
    -2147483648
    2147483647
    -9223372036854775808
    9223372036854775807
    -3.4028235e+38
    3.4028235e+38
    1.1920929e-07
    -1.7976931348623157e+308
    1.7976931348623157e+308
    2.220446049250313e-16



```python
import sys 
# np.set_printoptions(threshold=sys.maxsize)
z = np.zeros((25,25))
print(z)
```

:heavy_check_mark: Output

    [[0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]
     [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.
      0.]]


### 在数组中找到最接近给定标量的值


```python
z = np.arange(5,100)
v = np.random.uniform(0,100)
index = (np.abs(z-v)).argmin()
index, z[index]
```

:heavy_check_mark: Output


    (94, 99)



### 创建表示位置(x,y) 和颜色 (r,g,b)的结构化数组


```python
np.zeros(10, [ ('position', [ ('x', float),('y', float)]),
('color', [ ('r', float),('g', float),('b', float)])])
```

:heavy_check_mark: Output


    array([((0., 0.), (0., 0., 0.)), ((0., 0.), (0., 0., 0.)),
           ((0., 0.), (0., 0., 0.)), ((0., 0.), (0., 0., 0.)),
           ((0., 0.), (0., 0., 0.)), ((0., 0.), (0., 0., 0.)),
           ((0., 0.), (0., 0., 0.)), ((0., 0.), (0., 0., 0.)),
           ((0., 0.), (0., 0., 0.)), ((0., 0.), (0., 0., 0.))],
          dtype=[('position', [('x', '<f8'), ('y', '<f8')]), ('color', [('r', '<f8'), ('g', '<f8'), ('b', '<f8')])])



### 逐点查找(10,2)的随机向量表示坐标的距离


```python
import scipy
import scipy.spatial
z = np.random.random((10,2))
z
```

:heavy_check_mark: Output


    array([[0.61373192, 0.72074613],
           [0.65178911, 0.38888013],
           [0.00587313, 0.90245226],
           [0.48918031, 0.32632952],
           [0.16390973, 0.88363925],
           [0.34698864, 0.36736331],
           [0.54237694, 0.31358692],
           [0.36463891, 0.92062837],
           [0.96771595, 0.51868705],
           [0.94809115, 0.2881894 ]])




```python
# 计算
x, y = np.atleast_2d(z[:,0]), np.atleast_2d(z[:,1])
d1 = np.sqrt((x-x.T)**2+(y-y.T)**2)
# scipy计算
d2  = scipy.spatial.distance.cdist(z,z)
d1,d2
```

:heavy_check_mark: Output


    (array([[0.        , 0.33404101, 0.6344363 , 0.41361524, 0.47840795,
             0.44275433, 0.41336444, 0.31937475, 0.40759363, 0.54671877],
            [0.33404101, 0.        , 0.82520529, 0.17422457, 0.69484738,
             0.305559  , 0.13281601, 0.60432725, 0.34155468, 0.31294331],
            [0.6344363 , 0.82520529, 0.        , 0.75199949, 0.15915243,
             0.6345707 , 0.79661705, 0.35922591, 1.03557585, 1.12476381],
            [0.41361524, 0.17422457, 0.75199949, 0.        , 0.64528682,
             0.14799407, 0.05470151, 0.60720811, 0.51574972, 0.46049302],
            [0.47840795, 0.69484738, 0.15915243, 0.64528682, 0.        ,
             0.54777617, 0.68424929, 0.20410879, 0.88277661, 0.98463243],
            [0.44275433, 0.305559  , 0.6345707 , 0.14799407, 0.54777617,
             0.        , 0.20265362, 0.55354653, 0.63890631, 0.60629426],
            [0.41336444, 0.13281601, 0.79661705, 0.05470151, 0.68424929,
             0.20265362, 0.        , 0.63252679, 0.47220688, 0.40650836],
            [0.31937475, 0.60432725, 0.35922591, 0.60720811, 0.20410879,
             0.55354653, 0.63252679, 0.        , 0.72474736, 0.86046241],
            [0.40759363, 0.34155468, 1.03557585, 0.51574972, 0.88277661,
             0.63890631, 0.47220688, 0.72474736, 0.        , 0.23133157],
            [0.54671877, 0.31294331, 1.12476381, 0.46049302, 0.98463243,
             0.60629426, 0.40650836, 0.86046241, 0.23133157, 0.        ]]),
     array([[0.        , 0.33404101, 0.6344363 , 0.41361524, 0.47840795,
             0.44275433, 0.41336444, 0.31937475, 0.40759363, 0.54671877],
            [0.33404101, 0.        , 0.82520529, 0.17422457, 0.69484738,
             0.305559  , 0.13281601, 0.60432725, 0.34155468, 0.31294331],
            [0.6344363 , 0.82520529, 0.        , 0.75199949, 0.15915243,
             0.6345707 , 0.79661705, 0.35922591, 1.03557585, 1.12476381],
            [0.41361524, 0.17422457, 0.75199949, 0.        , 0.64528682,
             0.14799407, 0.05470151, 0.60720811, 0.51574972, 0.46049302],
            [0.47840795, 0.69484738, 0.15915243, 0.64528682, 0.        ,
             0.54777617, 0.68424929, 0.20410879, 0.88277661, 0.98463243],
            [0.44275433, 0.305559  , 0.6345707 , 0.14799407, 0.54777617,
             0.        , 0.20265362, 0.55354653, 0.63890631, 0.60629426],
            [0.41336444, 0.13281601, 0.79661705, 0.05470151, 0.68424929,
             0.20265362, 0.        , 0.63252679, 0.47220688, 0.40650836],
            [0.31937475, 0.60432725, 0.35922591, 0.60720811, 0.20410879,
             0.55354653, 0.63252679, 0.        , 0.72474736, 0.86046241],
            [0.40759363, 0.34155468, 1.03557585, 0.51574972, 0.88277661,
             0.63890631, 0.47220688, 0.72474736, 0.        , 0.23133157],
            [0.54671877, 0.31294331, 1.12476381, 0.46049302, 0.98463243,
             0.60629426, 0.40650836, 0.86046241, 0.23133157, 0.        ]]))



### 二维数组中随机放置p个元素
`numpy.random.choice(a, size=None, replace=True, p=None)` 随机取样

replace:代表是否放回,False代表不放回


```python
n,p = 10,3
z = np.zeros((n,n))
np.put(z,np.random.choice(range(n*n),p,replace = False),1)
```


```python
z
```

:heavy_check_mark: Output


    array([[0., 0., 0., 0., 0., 0., 0., 1., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 1.],
           [0., 0., 0., 0., 1., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.],
           [0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]])




```python
np.random.choice(range(n*n),3,replace = False)
```

:heavy_check_mark: Output


    array([ 5,  4, 29])



### 如何将浮点(32位)数组转为整数(32位)


```python
z = np.arange(10,dtype = np.float32)
print(z)
z = z.astype(np.int32,copy = False)
z 
```

:heavy_check_mark: Output

    [0. 1. 2. 3. 4. 5. 6. 7. 8. 9.]

:heavy_check_mark: Output

    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])



### 读取以下格式文件


```python
z = np.genfromtxt("./data_set/missing.dat",delimiter=",")
z
```

:heavy_check_mark: Output


    array([[ 1.,  2.,  3.,  4.,  5.],
           [ 6., nan, nan,  7.,  8.],
           [nan, nan,  9., 10., 11.]])



### `numpy`数组的枚举可以用什么其他形式表示


```python
z = np.arange(9).reshape(3,3)
for index, value in np.ndenumerate(z):
    print(index,value)
for index in np.ndindex(z.shape):
    print(index)
```

:heavy_check_mark: Output

    (0, 0) 0
    (0, 1) 1
    (0, 2) 2
    (1, 0) 3
    (1, 1) 4
    (1, 2) 5
    (2, 0) 6
    (2, 1) 7
    (2, 2) 8
    (0, 0)
    (0, 1)
    (0, 2)
    (1, 0)
    (1, 1)
    (1, 2)
    (2, 0)
    (2, 1)
    (2, 2)


### 生成一个二维高斯数组


```python
X, Y = np.meshgrid(np.linspace(-1,1,10), np.linspace(-1,1,10))
D = np.sqrt(X*X+Y*Y)
sigma, mu = 1.0, 0.0
G = np.exp(-( (D-mu)**2 / ( 2.0 * sigma**2 ) ) )
print(G)
```

:heavy_check_mark: Output

    [[0.36787944 0.44822088 0.51979489 0.57375342 0.60279818 0.60279818
      0.57375342 0.51979489 0.44822088 0.36787944]
     [0.44822088 0.54610814 0.63331324 0.69905581 0.73444367 0.73444367
      0.69905581 0.63331324 0.54610814 0.44822088]
     [0.51979489 0.63331324 0.73444367 0.81068432 0.85172308 0.85172308
      0.81068432 0.73444367 0.63331324 0.51979489]
     [0.57375342 0.69905581 0.81068432 0.89483932 0.9401382  0.9401382
      0.89483932 0.81068432 0.69905581 0.57375342]
     [0.60279818 0.73444367 0.85172308 0.9401382  0.98773022 0.98773022
      0.9401382  0.85172308 0.73444367 0.60279818]
     [0.60279818 0.73444367 0.85172308 0.9401382  0.98773022 0.98773022
      0.9401382  0.85172308 0.73444367 0.60279818]
     [0.57375342 0.69905581 0.81068432 0.89483932 0.9401382  0.9401382
      0.89483932 0.81068432 0.69905581 0.57375342]
     [0.51979489 0.63331324 0.73444367 0.81068432 0.85172308 0.85172308
      0.81068432 0.73444367 0.63331324 0.51979489]
     [0.44822088 0.54610814 0.63331324 0.69905581 0.73444367 0.73444367
      0.69905581 0.63331324 0.54610814 0.44822088]
     [0.36787944 0.44822088 0.51979489 0.57375342 0.60279818 0.60279818
      0.57375342 0.51979489 0.44822088 0.36787944]]


### 矩阵减去每一行的均值


```python
x = np.random.rand(5,10)
# 新版本
y_new = x - x.mean(axis = 1,keepdims = True)
# 旧版本计算方法
y_old = x - x.mean(axis=1).reshape(-1,1) 
x,y_new,y_old
```

:heavy_check_mark: Output


    (array([[0.22091606, 0.59224867, 0.80771446, 0.72202487, 0.20325647,
             0.17989501, 0.72351842, 0.12631062, 0.15316724, 0.44809685],
            [0.24654954, 0.0464483 , 0.03986491, 0.56156426, 0.27548312,
             0.39618653, 0.54447353, 0.68036678, 0.73601584, 0.50260717],
            [0.17687598, 0.63097471, 0.98953578, 0.72338948, 0.16698291,
             0.19685321, 0.53455385, 0.9666933 , 0.07335132, 0.14924995],
            [0.4026949 , 0.96986628, 0.75920739, 0.58032775, 0.71476869,
             0.61793634, 0.30935818, 0.64686345, 0.42027672, 0.73005127],
            [0.85024155, 0.63801797, 0.55441926, 0.91413514, 0.6935024 ,
             0.16462285, 0.23796274, 0.64870624, 0.55408353, 0.93722473]]),
     array([[-0.19679881,  0.1745338 ,  0.38999959,  0.30431   , -0.21445839,
             -0.23781986,  0.30580356, -0.29140425, -0.26454763,  0.03038198],
            [-0.15640645, -0.3565077 , -0.36309109,  0.15860826, -0.12747288,
             -0.00676946,  0.14151753,  0.27741078,  0.33305985,  0.09965117],
            [-0.28397007,  0.17012866,  0.52868974,  0.26254343, -0.29386314,
             -0.26399284,  0.0737078 ,  0.50584725, -0.38749473, -0.3115961 ],
            [-0.2124402 ,  0.35473118,  0.14407229, -0.03480734,  0.09963359,
              0.00280125, -0.30577692,  0.03172835, -0.19485838,  0.11491617],
            [ 0.23094991,  0.01872633, -0.06487238,  0.2948435 ,  0.07421076,
             -0.45466879, -0.3813289 ,  0.0294146 , -0.06520811,  0.31793309]]),
     array([[-0.19679881,  0.1745338 ,  0.38999959,  0.30431   , -0.21445839,
             -0.23781986,  0.30580356, -0.29140425, -0.26454763,  0.03038198],
            [-0.15640645, -0.3565077 , -0.36309109,  0.15860826, -0.12747288,
             -0.00676946,  0.14151753,  0.27741078,  0.33305985,  0.09965117],
            [-0.28397007,  0.17012866,  0.52868974,  0.26254343, -0.29386314,
             -0.26399284,  0.0737078 ,  0.50584725, -0.38749473, -0.3115961 ],
            [-0.2124402 ,  0.35473118,  0.14407229, -0.03480734,  0.09963359,
              0.00280125, -0.30577692,  0.03172835, -0.19485838,  0.11491617],
            [ 0.23094991,  0.01872633, -0.06487238,  0.2948435 ,  0.07421076,
             -0.45466879, -0.3813289 ,  0.0294146 , -0.06520811,  0.31793309]]))



### 对数组的第n列进行排序


```python
z = np.random.randint(0,10,(3,3))
# 对第二列进行排序
z,z[:,1].argsort(), z[z[:,1].argsort()]
```

:heavy_check_mark: Output


    (array([[1, 6, 1],
            [0, 5, 1],
            [4, 6, 7]]),
     array([1, 0, 2], dtype=int64),
     array([[0, 5, 1],
            [1, 6, 1],
            [4, 6, 7]]))



### 在数组中找到与给定值最近的值



```python

Z = np.random.uniform(0,1,10)
z = 0.5
m = Z.flat[np.abs(Z - z).argmin()]
Z,z,m
```

:heavy_check_mark: Output


    (array([0.79044703, 0.43333829, 0.28991264, 0.59942902, 0.1629342 ,
            0.73238711, 0.31088062, 0.29231163, 0.16383304, 0.60473573]),
     0.5,
     0.43333829030262927)



### 创建一个具有`name`属性的数组类


```python
class NamedArray(np.ndarray):
    def __new__(cls, array, name="no name"):
        obj = np.asarray(array).view(cls)
        obj.name = name
        return obj
    def __array_finalize__(self, obj):
        if obj is None: return
        self.info = getattr(obj, 'name', "no name")
Z = NamedArray(np.arange(10), "range_10")
Z,Z.name
```

:heavy_check_mark: Output


    (NamedArray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]), 'range_10')



### 一个给定的向量，如何给第二个向量索引的每个元素加1(包含重复索引)?
`np.bincount`: 计算每个值出现的次数


```python

# Author: Brett Olsen
Z = np.ones(10)
I = np.random.randint(0,len(Z),20)
Z += np.bincount(I, minlength=len(Z))
I,Z

```

:heavy_check_mark: Output


    (array([8, 5, 8, 3, 8, 3, 2, 5, 7, 6, 5, 5, 5, 4, 0, 1, 8, 5, 2, 7]),
     array([2., 2., 3., 3., 2., 7., 2., 3., 5., 1.]))

